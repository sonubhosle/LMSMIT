const express = require('express');
const router = express.Router();
const jwt = require('jsonwebtoken');
const Book = require('../models/Book');

// JWT Secret
const JWT_SECRET = 'library_management_secret_key_2023';

// Verify Token Middleware
const verifyToken = (req, res, next) => {
    const token = req.headers['authorization']?.split(' ')[1];
    
    if (!token) {
        return res.status(401).json({
            success: false,
            message: 'Access denied. No token provided.'
        });
    }

    try {
        const verified = jwt.verify(token, JWT_SECRET);
        req.user = verified;
        next();
    } catch (error) {
        res.status(400).json({
            success: false,
            message: 'Invalid token'
        });
    }
};

// Apply authentication middleware to all routes
router.use(verifyToken);

// Get all books with pagination and search
router.get('/', async (req, res) => {
    try {
        const { page = 1, limit = 10, search, category } = req.query;
        const pageNum = parseInt(page);
        const limitNum = parseInt(limit);
        const skip = (pageNum - 1) * limitNum;

        // Build query
        let query = {};
        
        // Search query
        if (search && search.trim() !== '') {
            query.$or = [
                { title: { $regex: search, $options: 'i' } },
                { author: { $regex: search, $options: 'i' } },
                { isbn: { $regex: search, $options: 'i' } }
            ];
        }
        
        // Category filter
        if (category && category.trim() !== '') {
            query.category = category;
        }

        // Get total count
        const totalBooks = await Book.countDocuments(query);
        const totalPages = Math.ceil(totalBooks / limitNum);

        // Get books with pagination
        const books = await Book.find(query)
            .sort({ createdAt: -1 })
            .skip(skip)
            .limit(limitNum);

        res.json({
            success: true,
            books,
            total: totalBooks,
            page: pageNum,
            pages: totalPages,
            limit: limitNum
        });
    } catch (error) {
        console.error('Error fetching books:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'Server error'
        });
    }
});

// Get single book
router.get('/:id', async (req, res) => {
    try {
        const book = await Book.findById(req.params.id);

        if (!book) {
            return res.status(404).json({
                success: false,
                message: 'Book not found'
            });
        }

        res.json({
            success: true,
            book
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: error.message || 'Server error'
        });
    }
});

// Create new book - FIXED VERSION
router.post('/', async (req, res) => {
    try {
        const { title, author, isbn, publicationYear, price, quantity, category } = req.body;

        // Validation
        if (!title || !author || !publicationYear || !price || !quantity) {
            return res.status(400).json({
                success: false,
                message: 'Please provide all required fields'
            });
        }

        // REMOVED: Manual bookId generation
        // const bookId = `BOOK${Date.now().toString().slice(-6)}`; // REMOVE THIS LINE

        const book = new Book({
            // Don't include bookId - it will be auto-generated by the pre-save hook
            title,
            author,
            isbn: isbn || '',
            publicationYear,
            price,
            quantity,
            availableQuantity: quantity, // Set available quantity equal to total quantity initially
            category: category || 'General'
        });

        await book.save();

        res.status(201).json({
            success: true,
            message: 'Book created successfully',
            book
        });
    } catch (error) {
        console.error('Error creating book:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'Server error'
        });
    }
});

// Update book
router.put('/:id', async (req, res) => {
    try {
        const updates = req.body;
        const bookId = req.params.id;
        
        // Don't allow updates to bookId or availableQuantity
        delete updates.bookId;
        if (updates.availableQuantity) {
            delete updates.availableQuantity;
        }

        // Check if book exists
        const existingBook = await Book.findById(bookId);
        if (!existingBook) {
            return res.status(404).json({
                success: false,
                message: 'Book not found'
            });
        }

        // If quantity is being updated, adjust availableQuantity
        if (updates.quantity !== undefined) {
            const quantityChange = updates.quantity - existingBook.quantity;
            if (quantityChange > 0) {
                // If increasing quantity, also increase availableQuantity
                updates.availableQuantity = existingBook.availableQuantity + quantityChange;
            } else if (quantityChange < 0) {
                // If decreasing quantity, ensure we don't go below issued books
                const minQuantity = existingBook.quantity - existingBook.availableQuantity;
                if (updates.quantity < minQuantity) {
                    return res.status(400).json({
                        success: false,
                        message: `Cannot reduce quantity below ${minQuantity} (${existingBook.quantity - existingBook.availableQuantity} books are currently issued)`
                    });
                }
                updates.availableQuantity = existingBook.availableQuantity + quantityChange;
            }
        }

        const book = await Book.findByIdAndUpdate(
            bookId,
            { $set: updates },
            { new: true, runValidators: true }
        );

        res.json({
            success: true,
            message: 'Book updated successfully',
            book
        });
    } catch (error) {
        console.error('Error updating book:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'Server error'
        });
    }
});

// Delete book
router.delete('/:id', async (req, res) => {
    try {
        const bookId = req.params.id;

        // Check if book exists
        const book = await Book.findById(bookId);
        if (!book) {
            return res.status(404).json({
                success: false,
                message: 'Book not found'
            });
        }

        // Check if book is issued (availableQuantity < quantity)
        if (book.availableQuantity < book.quantity) {
            return res.status(400).json({
                success: false,
                message: 'Cannot delete book that is currently issued'
            });
        }

        await Book.findByIdAndDelete(bookId);

        res.json({
            success: true,
            message: 'Book deleted successfully'
        });
    } catch (error) {
        console.error('Error deleting book:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'Server error'
        });
    }
});

// Get book statistics
router.get('/stats/summary', async (req, res) => {
    try {
        const books = await Book.find();
        const totalBooks = books.length;
        
        const totalValue = books.reduce((sum, book) => sum + (book.price * book.quantity), 0);
        const availableBooks = books.reduce((sum, book) => sum + book.availableQuantity, 0);

        // Simple category counting
        const categories = {};
        books.forEach(book => {
            const category = book.category || 'General';
            categories[category] = (categories[category] || 0) + 1;
        });

        const topCategories = Object.entries(categories)
            .map(([name, count]) => ({ _id: name, count }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 5);

        res.json({
            success: true,
            stats: {
                totalBooks,
                totalValue,
                availableBooks,
                topCategories
            }
        });
    } catch (error) {
        console.error('Error fetching stats:', error);
        res.status(500).json({
            success: false,
            message: error.message || 'Server error'
        });
    }
});

module.exports = router;